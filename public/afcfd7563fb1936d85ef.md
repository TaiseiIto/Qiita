---
title: Buddy memory allocator（っぽいもの）作ってみた！
tags:
  - メモリアロケータ
  - 自作OS
private: false
updated_at: '2024-12-08T00:00:17+09:00'
id: afcfd7563fb1936d85ef
organization_url_name: null
slide: false
ignorePublish: false
---
# はじめに

こんにちは．[だいみょーじん](https://x.com/Egh2Deywos)です．
この記事は，[第38回自作OSもくもく会](https://osdev-jp.connpass.com/event/312330/)で発表した内容をまとめ，[自作OSアドベントカレンダー2024](https://adventar.org/calendars/10539)の8日目の記事として公開したものです．
私が開発しているRust製の自作OS，[HeliOS](https://github.com/TaiseiIto/HeliOS)におけるメモリ管理アルゴリズムについて解説します．
[HeliOS](https://github.com/TaiseiIto/HeliOS)はx64アーキテクチャ上で動作するOSで，以降の説明においてもx64アーキテクチャを想定します．
また，以降登場する全てのコードはRustです．

# OSにおけるメモリ管理

OSの役割のひとつにメモリ管理があります．
OSは，OS自身が使用するメモリを確保したり，
![kmalloc.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/0540ffee-ad5b-a89f-3b32-6edbf8f1c3b9.png)
不要になったメモリを解放したり，
![kfree.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/9340a145-c0a4-7fac-a189-ebfc77ba08a8.png)
アプリケーションにメモリを供給したり，
![malloc.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/d0988b99-e363-634e-2f17-917e58855824.png)
アプリケーションからメモリを回収したりします．
![free.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/d241c1e0-4ef3-7f20-c6e6-26f45a088870.png)
様々なメモリ管理アルゴリズムがありますが，今回私が採用したのはメモリの確保と解放が高速なことで知られるBuddy memory allocatorです．

# Buddy memory allocator

### とりあえず挙動を見よう

Buddy memory allocatorがメモリを管理している様子を見てみましょう．
![buddy_memory_allocator.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/a2ad3335-3f80-53f7-470d-086e11e88068.png)
横軸がメモリ空間，縦軸が時間で，上から下に時間が流れています．

* 上図の1段目，32KiBのメモリがある状態で，4KiBのメモリを要求されます．
* 2段目，32KiBは要求に対して大きすぎるので，2つの16KiBに分割します．
* 3段目，16KiBも大きすぎるので，2つの8KiBに分割します．
* 4段目，8KiBも大きすぎるので，2つの4KiBに分割します．
* 5段目，要求と同サイズの4KiBのメモリができたので，左端の4KiBを要求者に与えます．ここでさらに7KiBのメモリが要求されます．
* 6段目，7KiBの要求に対して，中央の8KiBのメモリを要求者に与えます．
* 7段目，5段目で与えた4KiBが返されます．
* 8段目，左端に4KiBの空きメモリが2つ並んでいるので，統合して8KiBの空きメモリとします．ここで9KiBのメモリが要求されます．
* 9段目，9KiBの要求に対して，右端の16KiBのメモリを要求者に与えます．ここで7KiBの要求し対して6段目で与えた8KiBのメモリが返されます．
* 10段目，左に8KiBの空きメモリが2つ並んでいるので，統合して16KiBの空きメモリとします．
* 11段目，9KiBの要求に対して10段目で与えた16KiBのメモリが返されます．
* 12段目，16KiBの空きメモリが2つ並んでいるので，統合して32KiBの空きメモリとします．

このようにBuddy system allocatorでは，2の冪乗の大きさのメモリに対して，それを半分サイズの2つ組（バディ）に分割したり逆に分割されたバディを統合することにより，要求に対して適した大きさのメモリを出し入れします．

### 全二分木による表現

このようなBuddy memory allocatorの挙動を実現する方法はいくつかありますが，ここでは全二分木を使う方法を採用します．
前述の挙動を全二分木で表現してみましょう．
32KiBのメモリがある状態で，4KiBのメモリを要求されます．
![buddy_memory_allocator_tree_00.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/1b31302c-d862-1ce2-71f5-2c4832da79eb.png)
32KiBは要求に対して大きすぎるので，2つの16KiBに分割します．
![buddy_memory_allocator_tree_01.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/1990bea2-ffc9-da39-6616-92af03a5b0ee.png)
16KiBも大きすぎるので，2つの8KiBに分割します．
![buddy_memory_allocator_tree_02.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/4252067d-e155-c107-2f00-38999828e779.png)
8KiBも大きすぎるので，2つの4KiBに分割します．
![buddy_memory_allocator_tree_03.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/9fd19256-69bc-57d1-1740-10dec11d23e0.png)
要求と同サイズの4KiBのメモリができたので，左端の4KiBを要求者に与えます．
![buddy_memory_allocator_tree_04.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/8d4c38de-9d7b-d3dd-d30e-f9fc45e5a986.png)
7KiBのメモリが要求されます．
![buddy_memory_allocator_tree_05.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/36587ed8-72d3-e511-b1fd-dd00caef2f9c.png)
7KiBの要求に対して，中央の8KiBのメモリを要求者に与えます．
![buddy_memory_allocator_tree_06.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/c030e5f9-7264-8ec4-d175-596e40a2d057.png)
左端の4KiBが返されます．
![buddy_memory_allocator_tree_07.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/ad828bcf-538d-871d-8b0a-4d093119ba99.png)
左端に4KiBの空きメモリが2つ並んでいます．
![buddy_memory_allocator_tree_08.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/6a86c8d6-b22d-845a-f478-d409073b494d.png)
左端の2つの4KiBを統合して8KiBの空きメモリとします．
![buddy_memory_allocator_tree_09.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/06b52424-265d-0813-438c-babd2f20863f.png)
9KiBのメモリが要求されます．
![buddy_memory_allocator_tree_10.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/9475682f-70cf-cc5b-15db-33f734e04751.png)
9KiBの要求に対して，右端の16KiBのメモリを要求者に与えます．
![buddy_memory_allocator_tree_11.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/bfa5094b-64df-523f-b498-121cb9c1d7a6.png)
中央の7KiBが返されます．
![buddy_memory_allocator_tree_12.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/82614ecc-d339-3623-a6ce-50cdde89199e.png)
左端に8KiBの空きメモリが2つ並んでいます．
![buddy_memory_allocator_tree_13.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/34abced6-9abc-eba4-3548-b2210db71b05.png)
左端の2つの8KiBを統合して16KiBの空きメモリとします．
![buddy_memory_allocator_tree_14.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/fa20694b-4f1b-00b6-a22d-9786952b939e.png)
右端の9KiBが返されます．
![buddy_memory_allocator_tree_15.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/0ce9f275-123b-bd36-2b9b-2171400e4880.png)
16KiBの空きメモリが2つ並んでいます．
![buddy_memory_allocator_tree_16.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/93f54328-29da-00ae-96af-a995e488e9ac.png)
2つの16KiBを統合して32KiBの空きメモリとします．
![buddy_memory_allocator_tree_17.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/e6614e25-121e-8610-812a-bced28572d52.png)

このように，メモリの分割は親ノードからの子ノードの派生として表現され，メモリの統合は子ノードの親ノードへの吸収として表現されます．

# 初期化

このようなBuddy memory allocatorを構築する上で好ましいメモリ領域の性質が3つ挙げられます．

* きりの良いメモリアドレスから始まる．
* 2の冪乗のサイズを持つ．
* 連続している（間に使えない領域が散在していない）

しかし，実際のメモリマップは，割とごちゃごちゃしています．

![memory_map.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/f07a6891-c3ad-d6aa-dc9a-7de6251b2469.png)

ここで，まず切りの良いメモリアドレスから始まる連続領域を用意する手段として，ページングが考えられます．
ページングによって仮想アドレスから物理アドレスへの写像をうまいこといじくることによって，物理メモリ空間上に散在する利用可能な物理メモリ領域を，きりの良い仮想アドレス（0xffff_c000_0000_0000）から始まる連続した仮想メモリ領域にまとめることができます．

![buddy_memory_allocator_initialization.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/9d44c09c-5506-c56d-63d4-0e084d8c2084.png)

これにより，Buddy memory allocatorを構築する上で好ましいメモリ領域の3つの性質のうち，

* きりの良いメモリアドレスから始まる．
* 連続している（間に使えない領域が散在していない）

を満たすことができます．
残る性質は，「2の冪乗のサイズを持つ」ですが，利用可能な領域の大きさの合計がぴったり2の冪乗になることはほぼないでしょう．
この問題への対処として，2の冪乗のサイズを持つ「ヒープ領域」と，そのうち実際に利用可能な範囲である「利用可能領域」という2つの領域の情報を両方持っておくという方法があります．

![buddy_memory_allocator_30kib.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/dfb688bd-a974-7dbd-a280-b5d7d0c176b7.png)

上の図では，30MiBの利用可能領域に対して，実際には存在しない利用不可領域2MiBを付け加えることにより，ヒープ領域を32MiBにしています．

### HeliOSにおけるBuddy memory allocator初期化の具体的な流れ

上述したBuddy memory allocator初期化は，HeliOSでは以下のような手順で実装されています．

* UEFIの機能を使ってメモリマップを取得し，ヒープ領域の大きさを決める．
* UEFIのメモリアロケータを使用し，ヒープ領域の仮想アドレスから物理アドレスへの写像を表すページング階層構造を確保しておく．
* UEFIブートサービスを終了すると同時に再度メモリマップを取得する．
* ブートサービス終了時のメモリマップを参照し，ヒープ領域の全ページの仮想アドレスから物理アドレスへの写像を，確保したページング階層構造に書き込む． 

# 全二分木の表現

Buddy memory allocatorの全二分木は複数のノードで構成されますが，それらのノードの情報をどこに置くかに関して，大きく2つの選択肢があります．

* グローバルなデータ領域に固定長のノードリストを用意し，そこに置く．
* ヒープ領域内に置く．

前者の場合ノードリストの長さを静的に決める必要があります．
ノードリストが短すぎればメモリが十分に余っているにも関わらずメモリが確保できなくなる事態が発生しえます．
ノードリストが長すぎればノードリストの大部分が未使用となり，メモリの無駄が発生します．

後者の場合アルゴリズムが複雑になってしまいますが，需要に応じてある程度自由にノードの数を増減できるので，前者が抱える課題を解決できます．

今回は後者を採用することにしました．
利用可能領域の最後の4KiBページをノードリストとし，その分利用可能領域を減らします．

![buddy_memory_allocator_node_list.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/7f1db43a-8d4f-68aa-75ba-b21acc609ebd.png)

### ノードリストの構造

ノードリストは複数のノードを持ちます．
全二分木を構成する各ノードは，幅優先順でノードリストに格納されます．
幅優先順にすることで，ノードリスト内の$n$番目のノードの子ノードが$2n+1$番目と$2n+2$番目に決まるため，新しいノードを作るときにノードリスト内の空きを探す必要がなくなり，処理の高速化につながります．

![buddy_memory_allocator_node_list.drawio (1).png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/04e6017a-053f-2ed9-6491-5f0455dbff16.png)

ノードリストの長さは4KiBと決めたため，葉ノード$n$から2つの子ノード$2n+1$および$2n+2$を生やそうとした際に，それらがノードリストの範囲外に飛び出してしまう場合があります．
その場合，分割した2つのメモリ領域それぞれの最後尾の4KiBページを新たなノードリストとし，それらの先頭に，ノード$2n+1$およびノード$2n+2$をそれぞれ配置します．

![buddy_memory_allocator_new_node_list.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/ce0f9d6a-bf26-b328-1f51-296eefc916bc.png)

LinuxのBuddy memory allocatorは4KiBのページ単位でのメモリ管理を行っており，より細かいメモリ管理はSlab allocatorを使用しています．
今回のBuddy memory allocatorは，場合にもよりますが4KiBより細かくメモリを分割できます．

![buddy_memory_allocator_dividable.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/9b6d27ba-ad1d-165d-e9d4-33f17d4f5d92.png)

上の図の左のように，4KiBのメモリ領域を表すノード$n$が，ノードリスト内の十分に先頭寄りに存在する場合，そのメモリ領域をさらに細かく分割することができます．
上の図の右のように，4KiBのメモリ領域を表すノード$n$が，ノードリスト内の最後尾寄りに存在する場合，そのメモリ領域を分割するには新たなノードリストを作成する必要がありますが，ノードリストの長さは4KiBであり，新たなノードリストをそこに配置すると利用可能領域がなくなってしまうので，結局はこれ以上メモリを分割することができません．

### ノードの構造

ノードは，以下の構造体として，ノードリスト内に存在します．

* stateはノードが指し示すメモリの状態です．
* rangeはノードが指し示すメモリ領域のアドレスの範囲です．
* available_rangeはノードが指し示すメモリ領域のうちの利用可能領域のアドレスの範囲です．
* max_sizeはノードが供給できる最大のメモリの大きさです．

```Rust
struct Node {
    state: State,
    range: Range<usize>,
    available_range: Range<usize>,
    max_size: usize,
}
```

ノードの状態は，以下の列挙体で表現されます．

* Allocatedはノードが指し示すメモリが確保されている状態です．
* Dividedはノードが指し示すメモリが分割されている状態です．
* Freeはノードが指し示すメモリが解放されている状態です．
* Invalidはノードが指し示すメモリ全体が利用不可である状態です．

```Rust
enum State {
    Allocated,
    Divided,
    Free,
    Invalid,
}
```

# メモリの確保および解放の高速化

今回のBuddy memory allocatorは，メモリの確保および解放にかかる時間計算量が，ヒープ領域全体の大きさ$s$に対して$O\(\log s\)$となっています．
Node構造体のmax_sizeが，Buddy memory allocatorのメモリの確保および解放の高速化の役割を持っています．
例えば以下の図のように7KiB要求されて，全二分木を探索しまくって，最後の最後にようやく与えられる領域を見つけられたという状況を想像してみて下さい．

![buddy_memory_allocator_without_max_length.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/ac62d7e1-fc82-6b52-9a87-6be84cddace2.png)

__絶対に遅いです．__
そこでどうすれば早くなるかと考えてみると，各ノードが自分が供給できるメモリの最大量を教えてくれれば，根ノードから葉ノードまで迷うことなく一直線に進めるわけです．

![buddy_memory_allocator_with_max_length.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/b83ed378-87c5-6f29-ee6e-8597289045a7.png)

そして，確保するメモリ領域が確定したら，今度は来た道を戻るついでに各ノードのmax_sizeを更新してあげます．

![buddy_memory_allocator_with_max_length_after_alloc.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/f65fd924-5498-0e86-ae33-21f4c48d985d.png)

# 考察

今回紹介したBuddy memory allocatorは，以下のようなメリットが挙げられます．

* メモリの確保と解放を時間計算量$O\(\log s\)$でできるようになった（はず）
* 4KiBより細かく分割できる場所もある．

また，以下のデメリットが挙げられます．

* ヒープ領域のページングの初期化に時間がかかる（GPD MicroPCで約1分）
* 4KiBより細かく分割できない場所もある．

# まとめ

自作OSのメモリ管理として，Buddy memory allocator（っぽいもの）を作ってみました．
メモリを2分割したり，あるいは統合するという大まかな原理はLinuxのBuddy memory allocatorと同じですが，細かい部分は完全に我流です．

工夫した点

* 物理メモリ空間上に散在する利用可能領域を，ページングにより仮想メモリ空間上で連続した領域にまとめて扱いやすくした．
    * しかし，初期化に時間がかかるようになった．
* ノードリストをヒープ内に置くことで全二分木の柔軟性を上げた．
* ノードが供給できるメモリの大きさの最大値を持つことで，メモリの確保および解放にかかる時間計算量を$O\(\log s\)$に抑えることができた．

今回紹介したBuddy memory allocatorのソースコードは[こちら](https://github.com/TaiseiIto/HeliOS/blob/main/kernel/src/memory.rs)を参照してください．
