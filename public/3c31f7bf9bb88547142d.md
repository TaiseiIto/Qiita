---
title: OS自作のためのGNU make
tags:
  - Makefile
  - 自作OS
private: false
updated_at: '2025-12-20T22:03:11+09:00'
id: 3c31f7bf9bb88547142d
organization_url_name: null
slide: false
ignorePublish: false
---
# はじめに

こんにちは．[だいみょーじん](https://x.com/Egh2Deywos)です．
この記事は，[第46回自作OSもくもく会](https://www.youtube.com/watch?v=Eo_q-9CHOns&t=209s)で発表した内容をまとめ，[自作OSアドベントカレンダー2025](https://adventar.org/calendars/11966)の22日目の記事として公開したものです．
この記事では，GNU makeの基本から，[HeliOS](https://github.com/TaiseiIto/HeliOS)という自作OSのビルドなどに使っているいくつかの小技までを紹介しています．

# Make基本編

まずはMakeの一般的な使い方を紹介します．

## Makeとは？

一言でいうとビルド自動化ツールです．
ビルド手順を`Makefile`というファイルに記述しておくと，`make`コマンドでビルドできます．
`command`を実行することによって`source`から`target`を生成するとしましょう．

![rule.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/76aab18c-8776-48e3-a073-c5b7b46184bc.png)

これは，`Makefile`で以下のように記述できます．

```Makefile:Makefile
target: source
    command
```

より具体的に，`cc`で`hello.c`をコンパイルして`a.out`を生成したいとき，

![example.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/f987fce0-14e7-4cc1-84b9-4b00b7f08667.png)

これは`Makefile`で以下のように記述できます．

```Makefile:Makefile
a.out: hello.c
    cc hello.c
```

ひとつのターゲットに対して，ソースやコマンドを複数指定することも可能です．

![multi_source_multi_command.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/87bbda44-983a-4fba-9ec6-066a2ed6b524.png)

これは`Makefile`で以下のように記述できます．

```Makefile:Makefile
target: source0 source1 source2
    command0
    command1
    command2
```

このようなルールの集まりを`Makefile`に記述しておくと，コマンド`make <target>`でターゲットを生成できます．
また，コマンド`make`で，`Makefile`の一番上に記述されたターゲットを生成します．

## Makeの利点

### 大規模な依存関係の解決

OSのように比較的大規模なものになってくると，ソースから最終生成物にいたるまでの依存関係が複雑になります．

![dependency_tree.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/85e85d4b-0f76-407a-aeb9-7d35d6e42837.png)

この複雑な依存関係を`Makefile`に全て書いておけば，`make`コマンド一発でOSをビルドできます．

### 依存関係に基づいた最小限のビルド

`make`コマンドは，ソースが変更されていない場合はターゲットを再生成しません．
例えば下の図のように，一番上のソースだけを書き換えた場合は，図の左上と右のコマンドのみが実行されます．

![recompile.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/17c2cafa-e332-4aa0-b0a8-881eeba5719e.png)

必要最小限のコマンドだけを呼び出すことにより，ビルド時間の短縮に繋がります．

## 階層化

以下の図のように，子ディレクトリのソースコードから中間生成物を生成し，その中間生成物と親ディレクトリのソースコードから最終生成物を生成することを考えましょう．

![make_tree.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/7db0ae84-cbe2-47e5-8f00-1ceddc27476e.png)

この場合，まず子ディレクトリの`Makefile`で，子ディレクトリのソースコードから中間生成物を生成するというルールを書いておきます．
次に，親ディレクトリの`Makefile`で，子ディレクトリのソースコードからコマンド`make -C 子ディレクトリ`で子ディレクトリの`Makefile`を呼び出すことにより中間生成物を生成するというルールを書いておきます．
さらに親ディレクトリのソースコードと中間生成物から最終生成物を生成するルールも親ディレクトリの`Makefile`に書いておきます．
このように，`make`コマンドの`-C`オプションで別のディレクトリの`Makefile`を呼び出す機能を使うことで，`Makefile`をディレクトリ構造に合わせて階層化することができます．

## マクロ

`Makefile`では，`マクロ名=文字列`でマクロを定義できます．
`Makefile`内の`$(マクロ名)`が，定義された文字列に展開されます．
例えば，`hello.c`を`cc`でコンパイルして`hello`を生成するルール

```Makefile:Makefile
hello: hello.c
    cc hello.c -o hello
```

は，マクロを使ってこのように書き換えられます．

```Makefile:Makefile
SOURCE=hello.c
TARGET=hello

$(TARGET): $(SOURCE)
    cc $(SOURCE) -o $(TARGET)
```

また，以下のような暗黙的に定義済みであるマクロがあります．

* `$$`は`$`
* `$@`はターゲット名
* `$<`は最初のソース名
* `$^`は全てのソース名

これらを使うと，上のルールは

```Makefile:Makefile
SOURCE=hello.c
TARGET=hello

$(TARGET): $(SOURCE)
    cc $^ -o $@
```

と書き換えられます．

## 関数

マクロをさらに発展させた関数の機能もあります．
`$(関数名 第1引数, 第2引数,...)`という書き方で関数を呼び出せます．

### 既存の関数

以下のような関数が事前に用意されています．

* `$(addprefix dir/, a b c)`→`dir/a dir/b dir/c`
* `$(addsuffix .c, a b c)`→`a.c b.c c.c`
* `$(basename a.c b.c c.c)`→`a b c`
* `$(dir /a/b/c /d/e/f)`→`/a/b/ /d/e/`
* `$(notdir /a/b/c /d/e/f)`→`c f`
* `$(abspath paths)`→絶対パスに展開
* `$(realpath paths)`→シンボリックリンクの場合，参照先のパスに展開
* `$(wildcard *.c)`→カレントディレクトリ直下の全ての`.c`ファイル名の列に展開
* `$(shell command)`→`command`を実行し，その標準出力に展開

`shell`関数を実行するためのシェルは，`SHELL=/bin/bash`のように`SHELL`マクロで指定できます．
この関数の機能を使うと，先程のルールは以下のように書き換えられます．

```Makefile:Makefile
SOURCE=hello.c
TARGET=$(basename $(SOURCE))

$(TARGET): $(SOURCE)
    cc $^ -o $@
```

### 自作の関数

関数を自作することもできます．
通常のマクロと同様の書き方で定義します．
第n引数は，`$n`と書きます．
自作関数を呼び出すときは，`$(call 関数名, 第1引数, 第2引数, ...)`と書きます．
例えば，`MY_FUNC=hello $1`という関数を定義すると，`$(call MY_FUNC, world)`は`hello world`に展開されます．

## 拡張子に基づいたルール

これは以下の2つの機能により実現されます．

### 拡張子を変更する特殊なマクロ展開

例えば，`FILES=a.x b.x c.x`と定義されたマクロを，`$(FILES:.x=.y)`と呼び出すと，`a.y b.y c.y`に展開されます．

### 拡張子を変更したものを生成するルール

拡張子`.x`のソースから拡張子`.y`のターゲットを生成するルールは，具体的なファイルを個別に指定せずとも抽象的に`%.y: %.x`と書けます．

### 拡張子に基づいたルールの具体例

上の2つの機能を使うと，複数のアセンブリファイル`*.s`からオブジェクトファイル`*.o`を生成するルールを以下のようにまとめて書けます．

```Makefile:Makefile
# ソースの列挙
SOURCES=$(wildcard *.s)
# ターゲットの列挙
OBJECTS=$(SOURCES:.s=.o)

# ターゲットからソースへの依存関係のみを記述
# 生成コマンドが書かれていないので，makeは該当するルールを探す
$(OBJECTS): $(@:.o=.s)

# 生成コマンドはこちらに書く
%.o: %.s
    gcc $^ -c -nostdlib -Wall -Wextra -o $@
```

# Make応用編

ここからは，私が開発している[HeliOS](https://github.com/TaiseiIto/HeliOS)というOSのビルドで実際に使っている小技をいくつか紹介していきます．

## 小技その1：依存先の列挙

大規模なプロジェクトは大量のソースファイルを持っています．
それらのソースファイルを全部`Makefile`に書くのは大変です．
プロジェクトをGitでバージョン管理している場合，Gitを使ってこの問題を解決できます．
Gitはソースファイルのみを管理し，生成物は`.gitignore`で無視します．
つまり，ソースファイルの一覧をGitで取得できるはずなので，それをmakeに渡す方法があります．
以下がMakefileでGitを使って依存先を列挙する関数です．

```Makefile:.make/header.mk
SOURCE_FILES=$(shell git ls-files -- $1; git ls-files --others --exclude-standard -- $1)
```

この関数は，第1引数で指定されてディレクトリ以下にあるソースファイルを全て列挙します．
`git ls-files -- $1`で，指定ディレクトリ以下でGitに管理されている全てのファイルを列挙します．
`git ls-files --others --exclude-standard -- $1`で，指定ディレクトリ以下の`Untracked files`つまり新規のソースファイルを全て列挙します．
ただし，`README.md`とかも列挙されるので，注意して使いましょう．
このコマンドは汎用性の高いコマンドなので，[`.make/header.mk`](https://github.com/TaiseiIto/HeliOS/blob/c9754a97d2595a67d908f8caeb05b8e200f83601/.make/header.mk)で定義しておいて，複数の`Makefile`から

```Makefile:Makefile
include $(shell git rev-parse --show-toplevel)/.make/header.mk
```

で取り込んでいます．
`git rev-parse --show-toplevel`は，リポジトリのトップディレクトリのパスを取得するコマンドで，どれだけ深い階層の`Makefile`からも，この1行で目的のファイルを取り込むことができます．
取り込んだ側の`Makefile`で

```Makefile:Makefile
$(TARGET): $(call SOURCE_FILES, .)
    command
```

と書くことで，`TARGET`はこの`Makefile`が置かれているディレクトリ以下にあるすべてのソースファイルに依存します．

## 小技その2：中間生成物の場所の取得

これは親ディレクトリの`Makefile`で`$(call SUB_TARGET, 子ディレクトリ)`と書くと，子ディレクトリの`Makefile`に中間生成物の場所を問い合わせられる機能です．
`SUB_TARGET`関数は，[`.make/header.mk`](https://github.com/TaiseiIto/HeliOS/blob/c9754a97d2595a67d908f8caeb05b8e200f83601/.make/header.mk)で

```Makefile:.make/header.mk
SUB_TARGET=$(shell make target -C $1 -s)
```

と定義します．
`target`というターゲットは[`.make/footer.mk`](https://github.com/TaiseiIto/HeliOS/blob/c9754a97d2595a67d908f8caeb05b8e200f83601/.make/footer.mk)で

```Makefile:.make/footer.mk
.PHONY: target
target:
	@echo $(abspath $(TARGET))
```

と定義され，子Makefileの末尾で，

```Makefile:Makefile
include $(shell git rev-parse --show-toplevel)/.make/footer.mk
```

により取り込まれます．
こうすることで，生成物の名前を必ず`TARGET`というマクロに入れておけば，親Makefileから子Makefileに生成物の場所を問い合わせられます．

## 小技その3：sudoの継承

`sudo`で`make`が実行されたとき`sudo`という文字列に展開され，そうでない場合から文字列に展開されるマクロです．

```Makefile:Makefile
SUDO=$(shell if [ $$(id -u) -eq 0 ] && [ -n "$$(which sudo)" ]; then echo sudo; fi)
```

使いどころとしては，OSのディレクトリツリーをひとつのイメージファイルにまとめる時に，マウント，コピー，アンマウントの過程で`sudo`権限が必要になります．
ただし，Dockerコンテナの`root`で実行するときは`sudo`が要らなかったりするので，`sudo`で実行されたかどうかで判断しています．

```Makefile:Makefile
$(TARGET): $(call SOURCE_FILES, .)
    rm -f $@
    if mountpoint -q $(MOUNT_DIRECTORY); then umount -l $(MOUNT_DIRECTORY); fi
    rm -rf $(MOUNT_DIRECTORY)
    dd if=/dev/zero of=$@ ibs=$(BLOCK_SIZE) count=$(BLOCK_COUNT)
    mkfs.fat $@
    mkdir $(MOUNT_DIRECTORY)
    $(SUDO) mount -o loop $@ $(MOUNT_DIRECTORY) # マウント
    $(SUDO) make $(PROCESSOR_BOOT_LOADER_DESTINATION)
    $(SUDO) make $(PROCESSOR_KERNEL_DESTINATION)
    $(SUDO) make $(BOOTLOADER_DESTINATION) PROCESSOR_BOOT_LOADER=$(PROCESSOR_BOOT_LOADER) PROCESSOR_KERNEL=$(PROCESSOR_KERNEL) KERNEL=$(KERNEL)
    $(SUDO) make $(KERNEL_DESTINATION)
    for application in $(APPLICATIONS); do make -C $$application; done
    $(SUDO) mkdir -p $(APPLICATION_DESTINATION_DIRECTORY)
    $(SUDO) make $(APPLICATION_DESTINATIONS)
    $(SUDO) umount $(MOUNT_DIRECTORY) # アンマウント
    rm -rf $(MOUNT_DIRECTORY)
```

## 小技その4：QEMU上でOSを実行

HeliOSでは，`make run`コマンドでQEMU上でOSの動作確認ができるようにしています．

![Screenshot from 2025-12-20 14-36-16.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/c4269ab4-a438-44d0-9e8c-9b626befc03b.png)

`make run`コマンドを実行すると画面が左右に分割され，左の画面にはOSがRS232CのCOM2に出力した内容が，右の画面にはターミナルが表示されます．
では，この`make run`コマンドの中身を見てみましょう．
`Makefile`の`run`ターゲットは，`.tmux/Makefile`の`run`ターゲットを呼び出します．

```Makefile:Makefile
# Run the OS on QEMU.
# Usage: make run
.PHONY: run
run: $(TARGET)
	-make run -C .tmux -s
```

`.tmux/Makefile`の`run`ターゲットは，`tmux`で新しいセッションを作成し，そのセッションで`run.conf`を実行させます．
`.PHONY: run`は，`run`が偽のターゲットであり，コマンドを実行しても実際に`run`というファイルが生成されるわけではないということを示します．
ターゲットを生成することが目的ではなく，コマンドを実行することが目的であるようなルールを`Makefile`に書きたいときは，このように`.PHONY`ターゲットとして書きます．

```Makefile:.tmux/Makefile
# Run the OS on QEMU.
# Usage: make run
.PHONY: run
run:
	-tmux new-session \; source-file run.conf
```

`.tmux/run.conf`は，画面を左右に分割し，それぞれの画面でいくつかのコマンドを実行します．
そして，左側の画面で実行される`make run_on_tmux -s`が，QEMU上でHeliOSを動かすコマンドです．

```text:.tmux/run.conf
source-file ~/.tmux.conf
split-window -hc '#{pane_current_path}' # 画面を左右に分割
send-key -t 0 'cd ..' C-m # 左の画面で親ディレクトリに移動
send-key -t 0 'make run_on_tmux -s' C-m # 左の画面で"make run_on_tmux -s"を実行
send-key -t 1 'cd ..' C-m # 右の画面で親ディレクトリに移動
send-key -t 1 'make clippy' C-m # 右の画面で"make clippy"を実行
send-key -t 1 'make fmt' C-m # 右の画面で"make fmt"を実行
select-pane -t 1
```

`Makefile`の`run_on_tmux`ターゲットは，さらに`.qemu/Makefile`の`run`ターゲットを呼び出します．

```Makefile:Makefile
# Run the OS on QEMU.
# This target is called from .tmux/run.conf
# Don't execute this directly.
.PHONY: run_on_tmux
run_on_tmux:
	-make run -C .qemu OS_PATH=$(abspath $(TARGET)) OS_NAME=$(PRODUCT) TELNET_PORT=$(TELNET_PORT) -s
```

`.qemu/Makefile`の`run`ターゲットは，QEMUの起動コマンドと各種オプションをマクロで組み立てて実行しています．
`COM2`マクロとして定義されたオプションにより，RS232CのCOM2への出力を標準出力に表示しつつ，`COM2_LOG`マクロで定義されたファイルにも保存しています．

```Makefile:.qemu/Makefile
QEMU=qemu-system-x86_64
COM1=-serial file:$(COM1_LOG)
COM1_LOG=../com1.log
COM2=-chardev stdio,id=com2,mux=on,logfile=$(COM2_LOG) -serial chardev:com2
COM2_LOG=../com2.log
CPUS = -smp 2
LOG=-d int,cpu_reset -D $(LOG_PATH)
LOG_PATH=../qemu.log
MEMORY_SIZE=-m 1G
MONITOR=-monitor telnet::$(TELNET_PORT),server,nowait
NO_REBOOT=--no-reboot
OS=-drive file=fat:rw:$(OS_PATH),format=raw,id=$(OS_NAME),if=none -device ide-hd,drive=$(OS_NAME),bootindex=1
OVMF_CODE=-drive file=$(OVMF_CODE_PATH),format=raw,if=pflash,readonly=on
OVMF_CODE_PATH=../../qemu/roms/edk2/Build/OvmfX64/DEBUG_GCC5/FV/OVMF_CODE.fd
OVMF_VARS=-drive file=$(OVMF_VARS_PATH),format=raw,if=pflash,readonly=on
OVMF_VARS_PATH=../../qemu/roms/edk2/Build/OvmfX64/DEBUG_GCC5/FV/OVMF_VARS.fd
VNC=-vnc :0
DEBUG=-S -gdb tcp::$(DEBUG_PORT)
XHCI=-device qemu-xhci
COMMAND=$(QEMU) $(COM1) $(COM2) $(CPUS) $(LOG) $(MEMORY_SIZE) $(MONITOR) $(NO_REBOOT) $(OS) $(OVMF_CODE) $(OVMF_VARS) $(VNC) $(XHCI)

# Run the OS on QEMU.
# Usage: $ make run OS_PATH=<os directory path> OS_NAME=<os name>
.PHONY: run
run:
	-$(COMMAND)
```

実行が完了したら，`make stop`でtmuxのセッションを終了し，元の画面に戻ることができます．
このコマンドは，このあと説明する`make debug`や`make debug_qemu`で開いたtmuxのセッションを終了するときにも使えます．
`Makefile`の`stop`ターゲットは，`.tmux/Makefile`の`stop`ターゲットを呼び出します．

```Makefile:Makefile
# Stop the OS on QEMU.
# Usage: make stop
.PHONY: stop
stop:
	-make stop -C .tmux
```

`.tmux/Makefile`の`stop`ターゲットは，`Makefile`の`stop_on_tmux`ターゲットを呼び出します．

```Makefile:.tmux/Makefile
# Stop the OS on QEMU.
# Usage: make stop
.PHONY: stop
stop:
	-make stop_on_tmux -C ..
```

`Makefile`の`stop_on_tmux`ターゲットは，`.qemu/Makefile`の`stop`ターゲットを呼び出します．

```Makefile:Makefile
# Stop the OS on QEMU.
# This target is called from .tmux/Makefile
# Don't execute this directly.
.PHONY: stop_on_tmux
stop_on_tmux:
	-make stop -C .qemu TELNET_PORT=$(TELNET_PORT)
```

`.qemu/Makefile`の`stop`ターゲットは，Telnet経由でQEMUを終了し，tmuxのセッションを終了します．

```Makefile:.qemu/Makefile
# Stop the OS on QEMU.
# Usage: $ make stop
.PHONY: stop
stop:
	-echo quit | nc localhost $(TELNET_PORT)
	-tmux kill-server
```

## 小技その5：OSのデバッグ

`make debug`コマンドで，GDBからQEMU上で動いているOSにアタッチしてデバッグします．

![debug.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/5b04d8de-3ce8-4e6d-b0a6-acb988364e5a.png)

`make debug`コマンドを実行すると，こんな画面になります．

![Screenshot from 2025-12-20 16-21-14.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/8f331a14-962b-489d-ba6b-cb20e1809ae3.png)

`make run`のときと同様に画面が左右に分割されます．
左側の画面ではQEMU上でOSが実行され，RS232CのCOM2の出力が表示されます．
右側の画面ではGDBが起動しOSにアタッチしています．
`Makefile`の`debug`ターゲットは，`.tmux/Makefile`の`debug`ターゲットを呼び出します．

```Makefile:Makefile
# Debug the OS on QEMU by GDB.
# Usage: make debug
.PHONY: debug
debug: $(TARGET)
	-make debug -C .tmux -s
```

`.tmux/Makefile`の`debug`ターゲットは，tmuxで新しいセッションを立ち上げ，`.tmux/debug.conf`を実行します．

```Makefile:.tmux/Makefile
# Debug the OS on QEMU by GDB
# Usage: make debug
.PHONY: debug
debug:
	-tmux new-session \; source-file debug.conf
```

`.tmux/debug.conf`は，画面を左右に分割し，左側の画面で`Makefile`の`debug_on_tmux`ターゲットを，右側の画面で`.gdb/Makefile`の`debug`ターゲットを呼び出します．

```text:.tmux/debug.conf
source-file ~/.tmux.conf
split-window -hc '#{pane_current_path}' # 画面を左右に分割
send-key -t 0 'cd ..' C-m # 左側の画面で親ディレクトリに移動
send-key -t 0 'make debug_on_tmux -s' C-m # 左側の画面で"make debug_on_tmux -s"を実行
send-key -t 1 'cd ..' C-m # 右側の画面で親ディレクトリに移動
send-key -t 1 'make debug -C .gdb' C-m # 右側の画面で"make debug -C .gdb"を実行
select-pane -t 1
```

左右それぞれの画面における実行の流れを見てみましょう．

### 左側の画面で実行されること

左側の画面では`Makefile`の`debug_on_tmux`ターゲットが呼び出されます．
`Makefile`の`debug_on_tmux`ターゲットは，`.qemu/Makefile`の`debug`ターゲットを呼び出します．

```Makefile:Makefile
# Run the OS on QEMU.
# This target is called from .tmux/run.conf
# Don't execute this directly.
.PHONY: debug_on_tmux
debug_on_tmux:
	-make debug -C .qemu OS_PATH=$(abspath $(TARGET)) OS_NAME=$(PRODUCT) DEBUG_PORT=$(DEBUG_PORT) TELNET_PORT=$(TELNET_PORT) -s
```

`.qemu/Makefile`の`debug`ターゲットは，`-gdb tcp::$(DEBUG_PORT)`というオプションにより，TCPの`DEBUG_PORT`でGDBを待機する状態でQEMUを起動します．

```Makefile:.qemu/Makefile
QEMU=qemu-system-x86_64
COM1=-serial file:$(COM1_LOG)
COM1_LOG=../com1.log
COM2=-chardev stdio,id=com2,mux=on,logfile=$(COM2_LOG) -serial chardev:com2
COM2_LOG=../com2.log
CPUS = -smp 2
LOG=-d int,cpu_reset -D $(LOG_PATH)
LOG_PATH=../qemu.log
MEMORY_SIZE=-m 1G
MONITOR=-monitor telnet::$(TELNET_PORT),server,nowait
NO_REBOOT=--no-reboot
OS=-drive file=fat:rw:$(OS_PATH),format=raw,id=$(OS_NAME),if=none -device ide-hd,drive=$(OS_NAME),bootindex=1
OVMF_CODE=-drive file=$(OVMF_CODE_PATH),format=raw,if=pflash,readonly=on
OVMF_CODE_PATH=../../qemu/roms/edk2/Build/OvmfX64/DEBUG_GCC5/FV/OVMF_CODE.fd
OVMF_VARS=-drive file=$(OVMF_VARS_PATH),format=raw,if=pflash,readonly=on
OVMF_VARS_PATH=../../qemu/roms/edk2/Build/OvmfX64/DEBUG_GCC5/FV/OVMF_VARS.fd
VNC=-vnc :0
DEBUG=-S -gdb tcp::$(DEBUG_PORT) # デバッグオプション
XHCI=-device qemu-xhci
COMMAND=$(QEMU) $(COM1) $(COM2) $(CPUS) $(LOG) $(MEMORY_SIZE) $(MONITOR) $(NO_REBOOT) $(OS) $(OVMF_CODE) $(OVMF_VARS) $(VNC) $(XHCI)

# Debug the OS on QEMU by GDB.
# Usage: $ make debug OS_PATH=<os directory path> OS_NAME=<os name> DEBUG_PORT=<debug port>
.PHONY: debug
debug:
	-$(COMMAND) $(DEBUG)
```

`DEBUG_PORT`は`Makefile`で2159と定義されています．

```Makefile:Makefile
DEBUG_PORT=2159
```

### 右側の画面で実行されること

右側の画面では`.gdb/Makefile`の`debug`ターゲットが呼び出されます．
`.gdb/Makefile`の`debug`ターゲットは，GDBを起動します．

```Makefile:.gdb/Makefile
.PHONY: debug
debug:
	gdb
```

GDBは起動時に`.gdb/.gdbinit`を実行します．
`.gdb/.gdbinit`はQEMUが待機している2159番ポートにアタッチします．

```text:.gdb/.gdbinit
target remote localhost:2159
```

## 小技その6：QEMUのデバッグ

`make debug_qemu`コマンドで，GDBからOSを動かしているQEMUにアタッチしてデバッグします．

![debug_qemu.drawio.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/6c52e144-79b4-49ab-b8c6-cf61d626e18a.png)

`make debug_qemu`コマンドを実行すると，こんな画面になります．

![Screenshot from 2025-12-20 21-15-53.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/2354177/dcc6f4b8-9d28-4ca0-8f1d-9d7d73923124.png)

`make run`や`make debug`のときと同様に画面が左右に分割されます．
左側の画面ではQEMUがGDBにアタッチされ，main関数の先頭で一時停止しています．
右側の画面はソースコードの確認などのための画面で，QEMUのソースコードの場所に移動しています．
これを実現するには，まずQEMUをデバッグ可能な形でビルドしておく必要があります．
私はOSの開発環境をDockerイメージとして構築しています．
なので，`Dockerfile`にQEMUをデバッグ可能な形でビルドする手順を書いています．
QEMUのビルドを設定する際に，`CFLAGS`にCコンパイラに渡すオプションを，`CXXFLAGS`にC++コンパイラに渡すオプションを指定します．
これらに，最適化を抑制する`-O0`，デバッグ情報を埋め込む`-g`，関数のインライン化を抑制する`-fno-inline`を指定します．

```Dockerfile:.docker/Dockerfile
# Install QEMU.
RUN git clone --branch v8.1.0 --depth 1 --recursive --shallow-submodules --single-branch https://gitlab.com/qemu-project/qemu.git
WORKDIR qemu
RUN ./configure --target-list=x86_64-softmmu CFLAGS="-O0 -g -fno-inline" CXXFLAGS="-O0 -g -fno-inline"
RUN make
RUN make install
WORKDIR roms/edk2
RUN ./OvmfPkg/build.sh -a X64
WORKDIR ../../..
```

これでデバッグ可能なQEMUがインストールされます．
`Makefile`の`debug_qemu`ターゲットは，`.tmux/Makefile`の`debug_qemu`ターゲットを呼び出します．

```Makefile:Makefile
# Debug QEMU by GDB.
# Usage: make debug_qemu
.PHONY: debug_qemu
debug_qemu: $(TARGET)
	-make debug_qemu -C .tmux -s
```

`.tmux/Makefile`の`debug_qemu`ターゲットは，tmuxで新しいセッションを開き，`.tmux/debug_qemu.conf`を実行します．

```Makefile:.tmux/Makefile
# Debug QEMU by GDB
# Usage: make debug_qemu
.PHONY: debug_qemu
debug_qemu:
	-tmux new-session \; source-file debug_qemu.conf
```

`.tmux/debug_qemu.conf`は，画面を左右に分割し，左側の画面では`Makefile`の`debug_qemu_on_tmux`ターゲットを呼び出し，右側の画面ではQEMUのソースコードがある場所に移動します．

```text:.tmux/debug_qemu.conf
source-file ~/.tmux.conf
split-window -hc '#{pane_current_path}'
send-key -t 0 'cd ..' C-m
send-key -t 0 'make debug_qemu_on_tmux' C-m
send-key -t 1 'cat ../.qemu/.gdbinit' C-m
send-key -t 1 'cd ../../qemu/build' C-m
select-pane -t 0
```

`Makefile`の`debug_qemu_on_tmux`ターゲットは，`.qemu/Makefile`の`debug_qemu`ターゲットを呼び出します．

```Makefile:Makefile
# Run the OS on QEMU.
# This target is called from .tmux/run.conf
# Don't execute this directly.
.PHONY: debug_qemu_on_tmux
debug_qemu_on_tmux:
	-make debug_qemu -C .qemu OS_PATH=$(abspath $(TARGET)) OS_NAME=$(PRODUCT) TELNET_PORT=$(TELNET_PORT) -s
```

`.qemu/Makefile`の`debug_qemu`ターゲットは，GDBでQEMUをデバッグするコマンドを実行します．

```Makefile:.qemu/Makefile
QEMU=qemu-system-x86_64
COM1=-serial file:$(COM1_LOG)
COM1_LOG=../com1.log
COM2=-chardev stdio,id=com2,mux=on,logfile=$(COM2_LOG) -serial chardev:com2
COM2_LOG=../com2.log
CPUS = -smp 2
LOG=-d int,cpu_reset -D $(LOG_PATH)
LOG_PATH=../qemu.log
MEMORY_SIZE=-m 1G
MONITOR=-monitor telnet::$(TELNET_PORT),server,nowait
NO_REBOOT=--no-reboot
OS=-drive file=fat:rw:$(OS_PATH),format=raw,id=$(OS_NAME),if=none -device ide-hd,drive=$(OS_NAME),bootindex=1
OVMF_CODE=-drive file=$(OVMF_CODE_PATH),format=raw,if=pflash,readonly=on
OVMF_CODE_PATH=../../qemu/roms/edk2/Build/OvmfX64/DEBUG_GCC5/FV/OVMF_CODE.fd
OVMF_VARS=-drive file=$(OVMF_VARS_PATH),format=raw,if=pflash,readonly=on
OVMF_VARS_PATH=../../qemu/roms/edk2/Build/OvmfX64/DEBUG_GCC5/FV/OVMF_VARS.fd
VNC=-vnc :0
DEBUG=-S -gdb tcp::$(DEBUG_PORT)
XHCI=-device qemu-xhci
COMMAND=$(QEMU) $(COM1) $(COM2) $(CPUS) $(LOG) $(MEMORY_SIZE) $(MONITOR) $(NO_REBOOT) $(OS) $(OVMF_CODE) $(OVMF_VARS) $(VNC) $(XHCI)

# Debug QEMU by GDB.
# Usage: $ make run OS_PATH=<os directory path> OS_NAME=<os name>
.PHONY: debug_qemu
debug_qemu:
	gdb --args $(COMMAND)
```

GDBは`.qemu/.gdbinit`を自動的に実行します．
ここでは`main`関数にブレークポイントを貼って実行するので，`main`関数の先頭で一時停止している状態になります．

```text:.qemu/.gdbinit
break main
run
```

## 小技その7：cargo clippyの自動化

`cargo clippy`は，Rustのコンパイル時にエラーや警告を出すほどのことではない指摘事項や，よりよい書き方を提案してくれるコマンドです．
OSは複数のバイナリからなり，HeliOSではひとつのcargoプロジェクトがひとつのバイナリを生成します．
いちいち各プロジェクトごとに`cargo clippy`を実行するのは面倒なので，`Makefile`の`clippy`ターゲットから，全てのプロジェクトに対して`cargo clippy`を呼び出すようにしています．

```Makefile:Makefile
# Clippy rust codes.
.PHONY: clippy
clippy:
	make clippy -C $(BOOTLOADER_DIRECTORY) PROCESSOR_BOOT_LOADER=$(PROCESSOR_BOOT_LOADER) PROCESSOR_KERNEL=$(PROCESSOR_KERNEL) KERNEL=$(KERNEL)
	make clippy -C $(KERNEL_DIRECTORY)
	make clippy -C $(PROCESSOR_KERNEL_DIRECTORY)
	for application in $(APPLICATIONS); do make clippy -C $$application; done
```

## 小技その8：cargo fmtの自動化

`cargo fmt`は，Rustのソースコードを整形してくれるコマンドで，これも`cargo clippy`と同様に書くプロジェクトごとに実行するのが面倒なため，`Makefile`の`fmt`ターゲットから呼び出すようにしています．

```Makefile:Makefile
# Format rust codes.
.PHONY: fmt
fmt:
	make fmt -C $(BOOTLOADER_DIRECTORY) PROCESSOR_BOOT_LOADER=$(PROCESSOR_BOOT_LOADER) PROCESSOR_KERNEL=$(PROCESSOR_KERNEL) KERNEL=$(KERNEL)
	make fmt -C $(KERNEL_DIRECTORY)
	make fmt -C $(PROCESSOR_KERNEL_DIRECTORY)
	for application in $(APPLICATIONS); do make fmt -C $$application; done
```

# まとめ

* Makeは，ビルド自動化ツールである
* 「ソースからコマンドでターゲットを生成する」というルールを`Makefile`に書き，`make`コマンドでビルドする
* 依存関係をルールとして`Makefile`に書くことで，規模が大きくなっても`make`だけでビルドできる
* `make`はファイルの最終更新時刻に基づき，無駄な再コンパイルを防ぎ，ビルド時間を短縮できる
* マクロや関数が使える
* `.PHONY`ターゲットを定義することで，ビルドだけでなく実行やデバッグと行ったちょっとした操作の自動化に使える

# 参考文献

* [Makefileの基本的な書き方まとめ](https://kzky.hatenablog.com/entry/2014/12/21/Makfile%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%9B%B8%E3%81%8D%E6%96%B9%E3%81%BE%E3%81%A8%E3%82%81)
* [Makeの関数一覧](https://tex2e.github.io/blog/makefile/functions)
* [HeliOSのリポジトリ](https://github.com/TaiseiIto/HeliOS/tree/c9754a97d2595a67d908f8caeb05b8e200f83601)
